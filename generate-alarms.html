<!DOCTYPE html>
<html>
<head>
    <title>Generate Alarm Sounds</title>
</head>
<body>
    <h1>Alarm Sound Generator</h1>
    <button onclick="generateAndDownload()">Generate and Download Alarms</button>

    <script>
        async function generateAlarmSound(type) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const duration = type === 'beep' ? 0.2 : 2.0;
            const sampleRate = audioContext.sampleRate;
            const frameCount = sampleRate * duration;
            
            const audioBuffer = audioContext.createBuffer(1, frameCount, sampleRate);
            const channelData = audioBuffer.getChannelData(0);
            
            switch(type) {
                case 'beep':
                    // Short beep at 880Hz
                    for (let i = 0; i < frameCount; i++) {
                        channelData[i] = Math.sin(880 * 2 * Math.PI * i / sampleRate) *
                            (1 - i / frameCount); // Fade out
                    }
                    break;
                    
                case 'siren':
                    // Siren effect (oscillating frequency)
                    for (let i = 0; i < frameCount; i++) {
                        const frequency = 500 + 300 * Math.sin(2 * Math.PI * i / sampleRate * 2);
                        channelData[i] = Math.sin(frequency * 2 * Math.PI * i / sampleRate) * 0.5;
                    }
                    break;
                    
                case 'bell':
                    // Bell-like sound
                    const frequencies = [440, 880, 1320];
                    for (let i = 0; i < frameCount; i++) {
                        let sample = 0;
                        frequencies.forEach(freq => {
                            sample += Math.sin(freq * 2 * Math.PI * i / sampleRate) *
                                Math.exp(-3 * i / frameCount);
                        });
                        channelData[i] = sample / frequencies.length;
                    }
                    break;
            }

            // Convert to WAV
            const wavData = audioBufferToWav(audioBuffer);
            return new Blob([wavData], { type: 'audio/wav' });
        }

        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;
            
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            
            const buffer32 = new Int32Array(44 + buffer.length * bytesPerSample);
            const view = new DataView(buffer32.buffer);
            
            /* RIFF identifier */
            writeString(view, 0, 'RIFF');
            /* RIFF chunk length */
            view.setUint32(4, 36 + buffer.length * bytesPerSample, true);
            /* RIFF type */
            writeString(view, 8, 'WAVE');
            /* format chunk identifier */
            writeString(view, 12, 'fmt ');
            /* format chunk length */
            view.setUint32(16, 16, true);
            /* sample format (raw) */
            view.setUint16(20, format, true);
            /* channel count */
            view.setUint16(22, numChannels, true);
            /* sample rate */
            view.setUint32(24, sampleRate, true);
            /* byte rate (sample rate * block align) */
            view.setUint32(28, sampleRate * blockAlign, true);
            /* block align (channel count * bytes per sample) */
            view.setUint16(32, blockAlign, true);
            /* bits per sample */
            view.setUint16(34, bitDepth, true);
            /* data chunk identifier */
            writeString(view, 36, 'data');
            /* data chunk length */
            view.setUint32(40, buffer.length * bytesPerSample, true);
            
            const samples = buffer.getChannelData(0);
            let offset = 44;
            for (let i = 0; i < samples.length; i++) {
                const sample = Math.max(-1, Math.min(1, samples[i]));
                view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                offset += 2;
            }
            
            return buffer32.buffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        async function generateAndDownload() {
            const types = ['beep', 'siren', 'bell'];
            
            for (let i = 0; i < types.length; i++) {
                const blob = await generateAlarmSound(types[i]);
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `alarm${i + 1}.mp3`;
                a.click();
                
                URL.revokeObjectURL(url);
            }
        }
    </script>
</body>
</html> 